---
title: "Cosmetic API Vignette"
author: "Vivi Feathers"
date: "2023-10-03"
output: 
  github_document:
    toc: true
    toc_depth: '3'
    df_print: tibble
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE)
```

This document is a vignette with the purpose of exploring how to read in data using a function created for
interacting with a specific API, as well as showing different types of data analyses that can be conducted on the data obtained.  

I’ll be demonstrating with the [*MAKEUP API*](http://makeup-api.herokuapp.com/) which contains cosmetic items' name, brand, type, price and rating. I’m going to build a few functions to interact with 2 endpoints: **product brand and product type**.

I will also summarize the statistics of price and rating by product type with all the data available. After data are fetched and cleaned based on the brand and/or type selected, I will merge the summaries with the fetched data and compare each item's price and rating verse price and rating summaries from the corresponding product type, thus the user may have some ideas about whether to choose this item or not.

The second part of the vignette focus on data exploration, I will investigate cosmetic items' brand, type, price and rating by creating some contingency tables, numerical summaries and couple of plots.

# Requirement
The following packages were used to create this document: 

  + `tidyverse`: used for data manipulation, piping and visualization  
  + `jsonlite`: used for interacting with JSON in the API and returning data in data frame  
  + `knitr`: used to manage code in R Markdown format  

```{r lib, echo = FALSE}
library(tidyverse)
library(jsonlite)
```

# API Interaction Functions

## `clean_data`
I created a data cleaning function that removes confusing columns and keep brand, name, product_type, price, currency, rating, description, image_link columns. It also omits records with missing price or 0.0 as price value, removes carriage returns from the name and description column. Additionally, it converts price to numeric values, rounds them to two decimal places and standardizes them as US dollars according to their currency name.(CAD*0.73,
GBP*1.22, and if currency is missing, I take it as USD by default). 

``` {r help1}
# create a data cleaning function that removes confusing columns, keep records with non-missing price, 
# removes carriage returns,converts price to numeric values, standardized them as US dollars according to 
# currency name.

clean_data <- function(df){
    df%>%
      select(brand, name, product_type, price, currency, rating, description, image_link) %>%
      filter (is.na(price) == FALSE & price != "0.0") %>%
      mutate(description = gsub("[\r\n]", "", description),
             name = gsub("[\r\n]", "", name),
             usd_price = if_else(is.na(currency) == TRUE, round(as.numeric(price)*1, digits =2),
                                 if_else(currency == "GBP", round(as.numeric(price)*1.22, digits =2),
                                         if_else(currency == "USD", round(as.numeric(price)*1, digits =2),
                                                 if_else(currency == "CAD", round(as.numeric(price)*0.73, digits =2), 0)))))
  }
```

## `price_sum` and `rating_sum`
I grabbed all the available data by calling the base URL in `fromJSON` function. After cleaned the raw "all_type" data frame by using the "clean_data" function. I summarized the price statistics (mean, median, 25th and 75th percentile) across product type. Then I removed the missing values from rating and calculated the rating statistics (mean, median, 25th and 75th percentile) by product type as well, At the end, I stored the results into two data frames: `price_sum` and `rating_sum`.
 
``` {r help2}
# use `fromJSON` function to get data frame from the base url and name it as "all_type"

all_type <- fromJSON("http://makeup-api.herokuapp.com/api/v1/products.json?")

# clean the raw "all_type" data frame by calling the "clean_data" function

all_type_clean <- clean_data(all_type)

#calculate the price statistics (mean, median, 25th and 75th percentile)

price_sum <- all_type_clean %>%
               group_by(product_type) %>%
               summarise(type_price_avg = mean(usd_price),
                         type_price_q1 = quantile(usd_price, probs = 0.25),
                         type_price_q3 = quantile(usd_price, probs = 0.75),
                         type_price_median = median(usd_price))
  
# remove the missing values from rating and calculate the rating statistics
  
rating_sum <- all_type_clean %>%
                filter(is.na(all_type_clean$rating) == FALSE) %>%
                group_by(product_type) %>%
                summarise(type_rate_avg = mean(rating),
                          type_rate_q1 = quantile(rating, probs = 0.25),
                          type_rate_q3 = quantile(rating, probs = 0.75),
                          type_rate_median = median(rating))
```

## `pick_makeup`
I created an API interaction function that fetches data based on user selected cosmetic brand or/and product type.

Step one, I set up the base URL which returns all the available data and the brand and type pool to limit user's selections in "benefit", "dior", "covergirl", "maybelline", "smashbox", "nyx", "clinique" as cosmetic brands and "lipstick", "foundation", "eyeliner", "eyeshadow", "mascara", "blush" as product types.

Step two, I checked the user's argument input valus to make sure both makeup_brand and makeup_type are character strings that within the brand and type pool, otherwise the function will stop executing.After making sure the input values are good, I paste them with the base URL to form the API endpoints.

Step three, I used `fromJSON` function to obtain a data frame from the "api_url" and name it as "target".

Step four, I cleaned the raw "target" data frame by calling the "clean_data" helper function, and stored the processed data frame in "target_clean".

Step five, I merged price and rating summaries from "price_sum" and "rating_sum" data frames with "target_clean" data frame by product type.
  
Step six, I compared the price and rating of each observation from the "target_clean" data frame vs the corresponding price summary and rating summary from the same type products, and return "higher than", "equal to"
and "less than" accordingly.

Step seven, I pasted the item price, product type, price/rating summary and comparison results from step six together and output them into "price_stat" and "rating_stat" column as price and rating status for each observation.

Lastly, I returned the final data frame by keeping the necessary columns as brand, name, product_type, usd_price, price_stat, rating, rating_stat, description and image_link.

``` {r fun}
pick_makeup <- function(makeup_brand = NULL, makeup_type = NULL){
  
  # set up the base URL
  api_url <- "http://makeup-api.herokuapp.com/api/v1/products.json?"
  
  #set up brand and type option pool
  brand_base <- c("benefit", "dior", "covergirl", "maybelline", "smashbox", "nyx", "clinique")
  type_base <- c("lipstick", "foundation", "eyeliner", "eyeshadow", "mascara", "blush")
  
  # check the input values 
  if (!is.null(makeup_brand)){
    # makeup brand must be a characters string, if not, stop the function and return message.
    if (!is.character(makeup_brand)){
      stop("makeup brand must be a character string.")
    }
    # makeup brand must be selected from the brand pool, if not, stop the function and return message.
    makeup_brand <- tolower(makeup_brand)
    if (! (makeup_brand %in% brand_base)){
      stop("makeup brand must be selected from benefit, dior, covergirl, maybelline, smashbox, nyx and clinique.")
    }
    # if makeup_brand is not missing, it is a character string that from the brand pool, paste it into base url.
    api_url <- paste0(api_url, "brand=", makeup_brand)
  } # if makeup_brand is missing, leave "brand=" piece empty in the url 
  else{api_url <- paste0(api_url, "brand=")}
  
  if (!is.null(makeup_type)){
    # makeup type must be a characters string, if not, stop the function and return message.
    if (!is.character(makeup_type)){
      stop("makeup type must be a character string.")
    }
    # makeup type must be selected from the type pool, if not, stop the function and return message.
    makeup_type <- tolower(makeup_type)
    if (! (makeup_type %in% type_base)){
      stop("makeup type must be selected from lipstick, foundation, eyeliner, eyeshadow, mascara, blush.")
    }
    # if makeup_type is not missing, it is a character string that from the type pool, paste it into base url.
    api_url <- paste0(api_url, "&product_type=", makeup_type)
  }# if makeup_type is missing, the "api_url" remains unchanged
  
  # use `fromJSON` function to get data frame from the "api_url" we just set up and name it as "target"
  target <- fromJSON(api_url)
  
  # clean the raw "target" data frame by calling the "clean_data" function
  target_clean <- clean_data(target)
  
  # merge price and rating summaries with target data frame by product type and do the comparison
  
  target_price <- merge(target_clean, price_sum, by="product_type")
  target_price_rate <- merge( target_price, rating_sum, by="product_type")
  
  # compared the price and rating of each observation vs summaries from the same type products
  
  target2 <-  target_price_rate %>%
    mutate(comp_mean = if_else(usd_price > type_price_avg, "higher than",
                               if_else(usd_price < type_price_avg, "lower than",
                                       if_else(usd_price == type_price_avg, "equal to", ""))),
           comp_median = if_else(usd_price > type_price_median, "higher than",
                                 if_else(usd_price < type_price_median, "lower than",
                                         if_else(usd_price == type_price_median, "equal to", ""))),
           comp_q1 = if_else(usd_price > type_price_q1, "higher than",
                             if_else(usd_price < type_price_q1, "lower than",
                                     if_else(usd_price == type_price_q1, "equal to", ""))),
           comp_q3 = if_else(usd_price > type_price_q3, "higher than",
                             if_else(usd_price < type_price_q3, "lower than",
                                     if_else(usd_price == type_price_q3, "equal to", ""))),
           comp_rt_mean =  if_else(as.numeric(rating) > type_rate_avg, "higher than",
                                   if_else(as.numeric(rating) < type_rate_avg, "lower than",
                                           if_else(as.numeric(rating) == type_rate_avg, "equal to", ""))),
           comp_rt_median = if_else(as.numeric(rating) > type_rate_median, "higher than",
                                    if_else(as.numeric(rating) < type_rate_median, "lower than",
                                            if_else(as.numeric(rating) == type_rate_median, "equal to", ""))),
           comp_rt_q1 = if_else(as.numeric(rating) > type_rate_q1, "higher than",
                                if_else(as.numeric(rating) < type_rate_q1, "lower than",
                                        if_else(as.numeric(rating) == type_rate_q1, "equal to", ""))),
           comp_rt_q3 = if_else(as.numeric(rating) > type_rate_q3, "higher than",
                                if_else(as.numeric(rating) < type_rate_q3, "lower than",
                                        if_else(as.numeric(rating) == type_rate_q3, "equal to", ""))))
  
  # generate "price_stat" and "rating_stat" column by pasting the item price, product type, price/rating summary and comparison results
  
  target3 <- target2 %>%
    mutate(price_stat = paste0("This ", product_type, "'s price is $", usd_price, " which is ", comp_mean,
                               " the overall ", product_type, " price mean (", round(type_price_avg, digits=2), "), ", comp_median,
                               " the price median(", round(type_price_median, digits=2),"), ", comp_q1,
                               " the 25th percentile(", round(type_price_q1, digits=2),"), and ", comp_q3,
                               " the 75th percentile(", round(type_price_q3, digits=2),")."),
           rating_stat = if_else(is.na(rating)==TRUE, "No rating",
                                 paste0("This ", product_type, "'s rating is ", rating, " which is ", comp_rt_mean,
                                        " the overall ", product_type, " rating mean (", round(type_rate_avg, digits=2), "), ", comp_rt_median,
                                        " the rating median(", round(type_rate_median, digits=2),"), ", comp_rt_q1,
                                        " the 25th percentile(", round(type_rate_q1, digits=2),"), and ", comp_rt_q3,
                                        " the 75th percentile(", round(type_rate_q3, digits=2),").")))
  # keep necessary columns and return
  target_final <- target3 %>%
    select(brand, name, product_type, usd_price, price_stat, rating, rating_stat, description, image_link)
  return(target_final)
}

```

# Exploratory Data Analysis (EDA)
Now the API interaction function is done, I can explore some data analysis. 

## First call
First of all, let's call the API function without argument input and return all the available data, then convert cosmetic brand and product type as factors, so it is better for data analysis.

```{r ead}
# call the function and return all the data
all <- pick_makeup(makeup_brand = NULL, makeup_type = NULL)

# write a function to convert "brand" and "product_type" to factors
add_factor <- function(df_1) {
                    df_1 %>%
                       mutate(Cosmetic_Brand = as.factor(df_1$brand), Cosmetic_Type = as.factor(df_1$product_type))
}

all_factor <- add_factor(all)
```

### Two-way contingency table
Let's use a `table` function and create a two-way contingency table and break the item counts by brand and type.

``` {r twoway}
two_way <- table( all_factor$Cosmetic_Type,all_factor$Cosmetic_Brand)
two_way
```

### Create a stacked bar graph to present item count for each product type
use `gglot` and `geom_bar` to create a stacked bar graph 

```{r graphics, fig.width = 9, fig.height = 6}
library(ggplot2)
g <- ggplot(data = all_factor, aes(x = Cosmetic_Type, fill = Cosmetic_Type))
  g + geom_bar(alpha = 0.6) +
  labs(x = "Cosmetic Type", y = "Item count", title = "Bar Plot of Item Count for Each Cosmetic Type") 
```

### Find measures of center and spread for price by cosmetic types. 
I will write a get use price mean, standard deviation, variance, median and IQR by cosmetic type groups.

```{r mean}

 all_factor %>%
                   group_by(Cosmetic_Type) %>%
                   summarise(Mean = mean(usd_price),  Standard_Deviation = sd(usd_price), 
                             Variance = var(usd_price), Median = median(usd_price), 
                             q1 = quantile(usd_price, probs = 0.25),
                             q3 = quantile(usd_price, probs = 0.75))
```

### Violin plot for rating distribution across cosmetic brands
```{r graphics2, fig.width = 9, fig.height = 6}
#filter to 6 brands that have most non-missing rating
five_brand <- all_factor %>%
              filter(Cosmetic_Brand %in% c("l'oreal", "physicians formula", "covergirl", "maybelline", "revlon"))

p <- ggplot(data = five_brand, aes(x = Cosmetic_Brand, y = rating, fill = Cosmetic_Brand))
p + geom_violin(alpha = 0.6) +
scale_fill_manual(values=c("#EF6F6A", "#cc9900", "#69b3a2", "#404080", "#9172EC")) +
labs(x = "Cosmetic Brand", y = "Rating Distribution", title = "Violin Plot of rating distribution across cosmetic brands") 
```

### Create scatterplots relating usa_price rating

```{r graphics3, fig.width = 9, fig.height = 6}
  split <- function(br) {
        a <- five_brand %>%
              filter(Cosmetic_Brand == br)
  s <- ggplot(data = a, aes(y = rating, x = usd_price))
  s + geom_point( alpha = 0.5, size = 2, position = "jitter") +
  labs(y = "Rating", x="USA Price", title = paste0("Scatter Plot of the Relationship between Price vs Rating for brand ",br))}

split(quote(covergirl))
split(quote("l'oreal"))
split(quote("physicians formula"))
split(quote(maybelline))
split(quote(revlon))
```

## Second call
Call the API function again and get a subset data frame with only "maybelline" cosmetic products

```{r sub}
# call the function and return a subset data frame with only maybelline cosmetic products
mbl <- pick_makeup(makeup_brand = "maybelline", makeup_type = NULL)
mbl

mbl_factor <- add_factor(mbl)
mbl_factor
```

### Create a stacked bar graph to present item count for each product type
use `gglot` and `geom_bar` to create a stacked bar graph 
```{r graphics4, fig.width = 9, fig.height = 6}
q <- ggplot(data = mbl_factor, aes(x = Cosmetic_Type, fill = Cosmetic_Type))
  q + geom_bar(alpha = 0.7) +
  labs(x = "Cosmetic Type", y = "Item count", title = "Bar Plot of Item Count for Each Cosmetic Type of maybelline") 
```

### Find measures of center and spread for rating by product types. 
I will write a get rating mean, standard deviation, variance, median and IQR by costmetic type groups.

```{r mean1}

 mbl_factor %>%
            filter(is.na(rating) == FALSE) %>%
                   group_by(Cosmetic_Type) %>%
                   summarise(Mean = mean(rating),  Standard_Deviation = sd(rating), 
                             Variance = var(rating), Median = median(rating), 
                             q1 = quantile(rating, probs = 0.25),
                             q3 = quantile(rating, probs = 0.75))
```

### create a boxplot for price across product type groups.
```{r graphics5, fig.width = 9, fig.height = 6}
  b <- ggplot(data = mbl_factor, aes(y = usd_price, x = Cosmetic_Type, fill=Cosmetic_Type))
  b + geom_boxplot(adjust = 0.5, color="#e9ecef", alpha=0.5) +
  labs(y = "Price", x="Product Type", title = "Box Plot of Price Center and Spread Across Product Type Groups") 
```

# Wrap up