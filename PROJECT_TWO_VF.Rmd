---
title: "Project 2"
author: "Vivi Feathers"
date: "2023-10-03"
output: 
  github_document:
    toc: true
    toc_depth: '3'
    df_print: tibble
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE)
```

# Overwiew

This vignette is created for exploring makeup items, their brand, name, price, rating...

# Requirement and Packages.

```{r lib}
library(tidyverse)
library(jsonlite)
library(dplyr)
```

# API Interaction Functions
``` {r fun}
 pick_makeup <- function(makeup_brand = NULL, makeup_type = NULL){
  
  # set up the base URL
  api_url <- "http://makeup-api.herokuapp.com/api/v1/products.json?"
  
  #set up brand and type option pool
  brand_base <- c("benefit", "dior", "covergirl", "maybelline", "smashbox", "nyx", "clinique")
  type_base <- c("lipstick", "foundation", "eyeliner", "eyeshadow", "mascara", "blush")
  
  # check the input values 
  if (!is.null(makeup_brand)){
    # makeup brand must be a characters string, if not, stop the function and return message.
    if (!is.character(makeup_brand)){
      stop("makeup brand must be a character string.")
    }
    # makeup brand must be selected from the brand pool, if not, stop the function and return message.
    makeup_brand <- tolower(makeup_brand)
    if (! (makeup_brand %in% brand_base)){
      stop("makeup brand must be selected from benefit, dior, covergirl, maybelline, smashbox, nyx and clinique.")
    }
    # if makeup_brand is not missing, it is a character string that from the brand pool, paste it into base url.
    api_url <- paste0(api_url, "brand=", makeup_brand)
  } # if makeup_brand is missing, leave "brand=" piece empty in the url 
  else{api_url <- paste0(api_url, "brand=")}
  
  if (!is.null(makeup_type)){
    # makeup type must be a characters string, if not, stop the function and return message.
    if (!is.character(makeup_type)){
      stop("makeup type must be a character string.")
    }
    # makeup type must be selected from the type pool, if not, stop the function and return message.
    makeup_type <- tolower(makeup_type)
    if (! (makeup_type %in% type_base)){
      stop("makeup type must be selected from lipstick, foundation, eyeliner, eyeshadow, mascara, blush.")
    }
    # if makeup_type is not missing, it is a character string that from the type pool, paste it into base url.
    api_url <- paste0(api_url, "&product_type=", makeup_type)
  }# if makeup_type is missing, the "api_url" remains unchanged
  
# use `fromJSON` function to get data frame from the "api_url" we just set up and name it as "target"
target <- fromJSON(api_url)

# create a data cleaning function that removes confusing columns, keep records with non-missing price, removes carriage returns 
# from the description column, convert price to numeric values, standardized them as US dollars according to currency name.
clean_data <- function(df){
             df%>%
             select(brand, name, product_type, price, currency, rating, description, image_link) %>%
             filter (is.na(target$price) == FALSE & target$price != "0.0") %>%
             mutate(description = gsub("[\r\n]", "", description),
                    usd_price = if_else(is.na(currency) == TRUE, round(as.numeric(price)*1, digits =2),
                                   if_else(currency == "GBP", round(as.numeric(price)*1.22, digits =2),
                                        if_else(currency == "USD", round(as.numeric(price)*1, digits =2),
                                             if_else(currency == "CAD", round(as.numeric(price)*0.73, digits =2), 0)))))
}
# clean the raw "target" data frame by calling the "clean_data" function
target_clean <- clean_data(target)
# if makeup_type is missing, after getting cleaned by "clean_data" function and dropping the original price and 
# currency columns, "target_final" is the final data frame that will be returned

if (is.null(makeup_type)){
  target_final <- target_clean %>%
                    select(brand, name, product_type, usd_price, rating, description, image_link)
  return(target_final)
}
# if makeup_type is not missing,create an api url that grabs all the data from the same makeup type, summarize the price
# statistics (mean, median, 25th and 75th percentile) and the rating statistics (mean, median, 25th and 75th percentile).
# compare the price and rating of each observation from the "target_clean" data frame vs the price summary and rating summary
# from the same type product.
else {
  all_type_url <- paste0(api_url,"brand=&product_type=", makeup_type)
  # use `fromJSON` function to get data frame from the "all_type_url" we just set up and name it as "all_type"
  all_type <- fromJSON(all_type_url)
  # clean the raw "all_type" data frame by calling the "clean_data" function
  all_type_clean <- clean_data(all_type)
  #calculate the price statistics (mean, median, 25th and 75th percentile)
  type_price_avg <- mean(all_type_clean$usd_price)
  type_price_q1 <- quantile(all_type_clean$usd_price, probs = 0.25)
  type_price_q3 <- quantile(all_type_clean$usd_price, probs = 0.75)
  type_price_median <- median(all_type_clean$usd_price)

 # remove the missing values from rating, convert it to numeric 
 #and calculate the rating statistics (mean, median, 25th and 75th percentile)
 rate <- na.omit(all_type_clean$rating)%>%
          as.numeric()
 type_rate_avg <- mean(rate)
 type_rate_q1 <- quantile(rate, probs = 0.25)
 type_rate_q3 <- quantile(rate, probs = 0.75)
 type_rate_median <- median(rate)


 target2 <- target_clean %>%
            mutate(comp_mean = if_else(usd_price > type_price_avg, "higher than",
                                       if_else(usd_price < type_price_avg, "lower than",
                                               if_else(usd_price == type_price_avg, "equal to", ""))),
                   comp_median = if_else(usd_price > type_price_median, "higher than",
                                       if_else(usd_price < type_price_median, "lower than",
                                               if_else(usd_price == type_price_median, "equal to", ""))),
                   comp_q1 = if_else(usd_price > type_price_q1, "higher than",
                                         if_else(usd_price < type_price_q1, "lower than",
                                                 if_else(usd_price == type_price_q1, "equal to", ""))),
                   comp_q3 = if_else(usd_price > type_price_q3, "higher than",
                                     if_else(usd_price < type_price_q3, "lower than",
                                             if_else(usd_price == type_price_q3, "equal to", ""))),
                   comp_rt_mean =  if_else(as.numeric(rating) > type_rate_avg, "higher than",
                                       if_else(as.numeric(rating) < type_rate_avg, "lower than",
                                               if_else(as.numeric(rating) == type_rate_avg, "equal to", ""))),
                   comp_rt_median = if_else(as.numeric(rating) > type_rate_median, "higher than",
                                         if_else(as.numeric(rating) < type_rate_median, "lower than",
                                                 if_else(as.numeric(rating) == type_rate_median, "equal to", ""))),
                   comp_rt_q1 = if_else(as.numeric(rating) > type_rate_q1, "higher than",
                                     if_else(as.numeric(rating) < type_rate_q1, "lower than",
                                             if_else(as.numeric(rating) == type_rate_q1, "equal to", ""))),
                   comp_rt_q3 = if_else(as.numeric(rating) > type_rate_q3, "higher than",
                                     if_else(as.numeric(rating) < type_rate_q3, "lower than",
                                             if_else(as.numeric(rating) == type_rate_q3, "equal to", ""))))
  target3 <- target2 %>%
             mutate(price_stat = paste0("This ", product_type, "'s price is $", usd_price, " which is ", comp_mean,
                                        " the overall ", product_type, " price mean (", round(type_price_avg, digits=2), "), ", comp_median,
                                        " the price median(", round(type_price_median, digits=2),"), ", comp_q1,
                                        " the 25th percentile(", round(type_price_q1, digits=2),"), and ", comp_q3,
                                        " the 75th percentile(", round(type_price_q3, digits=2),")."),
                    rating_stat = if_else(is.na(rating)==TRUE, "No rating",
                                          paste0("This ", product_type, "'s rating is ", rating, " which is ", comp_rt_mean,
                                        " the overall ", product_type, " rating mean (", round(type_rate_avg, digits=2), "), ", comp_rt_median,
                                        " the rating median(", round(type_rate_median, digits=2),"), ", comp_rt_q1,
                                        " the 25th percentile(", round(type_rate_q1, digits=2),"), and ", comp_rt_q3,
                                        " the 75th percentile(", round(type_rate_q3, digits=2),").")))
  target_final <- target3 %>%
                  select(brand, name, product_type, usd_price, price_stat, rating, rating_stat, description, image_link)
  return(target_final)
}

 }

```

# Exploratory Data Analysis (EDA)

```{r ead}
# call the function and return all the data
all <- pick_makeup(makeup_brand = NULL, makeup_type = NULL)
all
# write a function to convert "brand" and "product_type" to factors
add_factor <- function(df_1) {
                    df_1 %>%
                       mutate(Cosmetic_Brand = as.factor(df_1$brand), Cosmetic_Type = as.factor(df_1$product_type))
}

all_factor <- add_factor(all)
all_factor
```


## Create a two-way contingency table and see how many items each brand has
``` {r twoway}
two_way <- table( all_factor$Cosmetic_Type,all_factor$Cosmetic_Brand)
two_way
```

## Create a stacked bar graph to present item count for each product type
use `gglot` and `geom_bar` to create a stacked bar graph 
```{r graphics, fig.width = 9, fig.height = 6}
library(ggplot2)
g <- ggplot(data = all_factor, aes(x = Cosmetic_Type, fill = Cosmetic_Type))
  g + geom_bar(alpha = 0.6) +
  labs(x = "Cosmetic Type", y = "Item count", title = "Bar Plot of Item Count for Each Cosmetic Type") 
```

## Find measures of center and spread for price by cosmetic types. 
I will write a get use price mean, standard deviation, variance, median and IQR by costmetic type groups.

```{r mean}

 all_factor %>%
                   group_by(Cosmetic_Type) %>%
                   summarise(Mean = mean(usd_price),  Standard_Deviation = sd(usd_price), 
                             Variance = var(usd_price), Median = median(usd_price), 
                             q1 = quantile(usd_price, probs = 0.25),
                             q3 = quantile(usd_price, probs = 0.75))
```

## Violin plot for rating distribution across cosmetic brands
```{r graphics2, fig.width = 9, fig.height = 6}
#filter to 6 brands that have most non-missing rating
five_brand <- all_factor %>%
              filter(Cosmetic_Brand %in% c("l'oreal", "physicians formula", "covergirl", "maybelline", "revlon"))

p <- ggplot(data = five_brand, aes(x = Cosmetic_Brand, y = rating, fill = Cosmetic_Brand))
p + geom_violin(alpha = 0.6) +
scale_fill_manual(values=c("#EF6F6A", "#cc9900", "#69b3a2", "#404080", "#9172EC")) +
labs(x = "Cosmetic Brand", y = "Rating Distribution", title = "Violin Plot of rating distribution across cosmetic brands") 
```

## Create scatterplots relating usa_price rating

```{r graphics3, fig.width = 9, fig.height = 6}
  split <- function(br) {
        a <- five_brand %>%
              filter(Cosmetic_Brand == br)
  s <- ggplot(data = a, aes(y = rating, x = usd_price))
  s + geom_point( alpha = 0.5, size = 2, position = "jitter") +
  labs(y = "Rating", x="USA Price", title = paste0("Scatter Plot of the Relationship between Price vs Rating for brand ",br))}

split(quote(covergirl))
split(quote("l'oreal"))
split(quote("physicians formula"))
split(quote(maybelline))
split(quote(revlon))
```
## Call the API function again and get a subset data frame with only maybelline cosmetic products

```{r sub}
# call the function and return a subset data frame with only maybelline cosmetic products
mbl <- pick_makeup(makeup_brand = "maybelline", makeup_type = NULL)
mbl

mbl_factor <- add_factor(mbl)
mbl_factor
```

## Create a stacked bar graph to present item count for each product type
use `gglot` and `geom_bar` to create a stacked bar graph 
```{r graphics4, fig.width = 9, fig.height = 6}
q <- ggplot(data = mbl_factor, aes(x = Cosmetic_Type, fill = Cosmetic_Type))
  q + geom_bar(alpha = 0.7) +
  labs(x = "Cosmetic Type", y = "Item count", title = "Bar Plot of Item Count for Each Cosmetic Type of maybelline") 
```

## Find measures of center and spread for rating by product types. 
I will write a get rating mean, standard deviation, variance, median and IQR by costmetic type groups.

```{r mean1}

 mbl_factor %>%
            filter(is.na(rating) == FALSE) %>%
                   group_by(Cosmetic_Type) %>%
                   summarise(Mean = mean(rating),  Standard_Deviation = sd(rating), 
                             Variance = var(rating), Median = median(rating), 
                             q1 = quantile(rating, probs = 0.25),
                             q3 = quantile(rating, probs = 0.75))
```

### create a boxplot for price across product type groups.
```{r graphics5, fig.width = 9, fig.height = 6}
  b <- ggplot(data = mbl_factor, aes(y = usd_price, x = Cosmetic_Type, fill=Cosmetic_Type))
  b + geom_boxplot(adjust = 0.5, color="#e9ecef", alpha=0.5) +
  labs(y = "Price", x="Product Type", title = "Box Plot of Price Center and Spread Across Product Type Groups") 
```